// boids.worker.js - plain JS version served from public
let canvas, ctx;
let positionsX, positionsY, velocitiesX, velocitiesY, targetsX, targetsY, states, neighborIndexPool, neighborPoolLength = 0;
let targetPoints = [], targetBitmap = null;
let NEIGHBOR_RADIUS = 15, NEIGHBOR_RADIUS_SQ = 225, MAX_NEIGHBORS = 3, cellSize = 30;
let mouseInfluenceRadius = 350, throttle = 60, maxSpeed = 3;
let pointer = { x: -1000, y: -1000 };
let hoverActive = false, hoverX = 0, hoverY = 0;
class Rectangle { constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h;} contains(px,py){return px>=this.x-this.w&&px<this.x+this.w&&py>=this.y-this.h&&py<this.y+this.h;} intersects(r){const xd=Math.abs(r.x-this.x), yd=Math.abs(r.y-this.y); return xd<=this.w+r.r&&yd<=this.h+r.r;} }
class Circle { constructor(x,y,r){this.x=x;this.y=y;this.r=r;} contains(px,py){const dx=px-this.x,dy=py-this.y;return dx*dx+dy*dy<=this.r*this.r;} }
class Quadtree { constructor(boundary,cap){this.boundary=boundary;this.capacity=cap;this.points=[];this.divided=false;} subdivide(){const b=this.boundary;const w=b.w/2,h=b.h/2;this.northeast=new Quadtree(new Rectangle(b.x+w,b.y-h,w,h),this.capacity);this.northwest=new Quadtree(new Rectangle(b.x-w,b.y-h,w,h),this.capacity);this.southeast=new Quadtree(new Rectangle(b.x+w,b.y+h,w,h),this.capacity);this.southwest=new Quadtree(new Rectangle(b.x-w,b.y+h,w,h),this.capacity);this.divided=true;} insert(p){if(!this.boundary.contains(p.x,p.y))return false; if(this.points.length<this.capacity){this.points.push(p);return true;} if(!this.divided)this.subdivide();return this.northeast.insert(p)||this.northwest.insert(p)||this.southeast.insert(p)||this.southwest.insert(p);} query(range,found){if(!this.boundary.intersects(range))return;for(const p of this.points){if(range.contains(p.x,p.y))found.push(p);}if(this.divided){this.northwest.query(range,found);this.northeast.query(range,found);this.southwest.query(range,found);this.southeast.query(range,found);} } clear(){this.points.length=0;this.divided=false;} }
let qt, foundPoints=[];
function initBuffers(){const N=targetPoints.length;positionsX=new Float32Array(N);positionsY=new Float32Array(N);velocitiesX=new Float32Array(N);velocitiesY=new Float32Array(N);targetsX=new Float32Array(N);targetsY=new Float32Array(N);states=new Uint8Array(N);neighborIndexPool=new Int32Array(N*9);neighborPoolLength=0; // build bitmap
const canvasOff=new OffscreenCanvas(canvas.width,canvas.height);const c=canvasOff.getContext('2d');c.fillStyle='rgba(255,255,255,0.2)';for(const pt of targetPoints){c.fillRect(pt.x,pt.y,1,1);}targetBitmap=canvasOff.transferToImageBitmap(); for(let i=0;i<N;i++){positionsX[i]=Math.random()*canvas.width;positionsY[i]=Math.random()*canvas.height;velocitiesX[i]=Math.random()*2-1;velocitiesY[i]=Math.random()*2-1;targetsX[i]=targetPoints[i].x;targetsY[i]=targetPoints[i].y;states[i]=Math.round(Math.random()*3);} }
function animate(){ctx.clearRect(0,0,canvas.width,canvas.height);if(targetBitmap)ctx.drawImage(targetBitmap,0,0);const boidPath=new Path2D();qt.clear();const N=positionsX.length;for(let i=0;i<N;i++){qt.insert({x:positionsX[i],y:positionsY[i],idx:i});}for(let idx=0;idx<N;idx++){const x=positionsX[idx],y=positionsY[idx],s=states[idx];const pts=[];qt.query(new Circle(x,y,NEIGHBOR_RADIUS),pts);let sepX=0,sepY=0,aliX=0,aliY=0,cohX=0,cohY=0,nc=0;for(const p of pts){if(p.idx!==idx&&states[p.idx]===s){sepX+=x-p.x;sepY+=y-p.y;aliX+=velocitiesX[p.idx];aliY+=velocitiesY[p.idx];cohX+=p.x;cohY+=p.y;nc++;if(nc>=MAX_NEIGHBORS)break;}}if(nc){sepX/=nc;sepY/=nc;aliX/=nc;aliY/=nc;cohX/=nc;cohY/=nc;const m=0;/* skipping norm for brevity*/}let tfX=0,tfY=0;if(hoverActive){const dx=hoverX-x,dy=hoverY-y,dist=Math.hypot(dx,dy);if(dist){const ang=Math.atan2(dy,dx)+((Math.random()*2-1)*Math.PI/4);tfX=Math.cos(ang);tfY=Math.sin(ang);}}else{const dx=targetsX[idx]-x,dy=targetsY[idx]-y,dds=dx*dx+dy*dy;if(dds>0.25){const d=Math.sqrt(dds),id=2/d;tfX=dx*id;tfY=dy*id;}}const mx=0,my=0;const fx=tfX+mx;velocitiesX[idx]=velocitiesX[idx]*0.95+fx*0.2;velocitiesY[idx]=velocitiesY[idx]*0.95+(tfY+my)*0.2;const sp=Math.hypot(velocitiesX[idx],velocitiesY[idx]);if(sp>maxSpeed){velocitiesX[idx]=velocitiesX[idx]/sp*maxSpeed;velocitiesY[idx]=velocitiesY[idx]/sp*maxSpeed;}positionsX[idx]+=velocitiesX[idx];positionsY[idx]+=velocitiesY[idx];const m2=new DOMMatrix([Math.cos(Math.atan2(velocitiesY[idx],velocitiesX[idx])), Math.sin(Math.atan2(velocitiesY[idx],velocitiesX[idx])), -Math.sin(Math.atan2(velocitiesY[idx],velocitiesX[idx])), Math.cos(Math.atan2(velocitiesY[idx],velocitiesX[idx])), x, y]);boidPath.addPath(baseBoidPath,m2);}ctx.fillStyle='rgba(255,255,255,0.7)';ctx.fill(boidPath);setTimeout(animate,1000/throttle);}self.onmessage=(e)=>{const d=e.data;switch(d.type){case'init':canvas=d.canvas;ctx=canvas.getContext('2d');targetPoints=d.targetPoints;initBuffers();qt=new Quadtree(new Rectangle(canvas.width/2,canvas.height/2,canvas.width/2,canvas.height/2),16);animate();break;case'resize':canvas.width=d.width;canvas.height=d.height;targetPoints=d.targetPoints;initBuffers();qt=new Quadtree(new Rectangle(canvas.width/2,canvas.height/2,canvas.width/2,canvas.height/2),16);break;case'pointer':pointer={x:d.x,y:d.y};break;case'hover':if(d.subtype==='start'){hoverActive=true;hoverX=d.x;hoverY=d.y;}else hoverActive=false;break;}};const baseBoidPath=new Path2D();baseBoidPath.moveTo(2,0);baseBoidPath.lineTo(-1,1);baseBoidPath.lineTo(-1,-1);baseBoidPath.closePath();
